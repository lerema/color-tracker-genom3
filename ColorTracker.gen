/*
 * Copyright (c) 2022-2022 LAAS/CNRS
 *
 * Author: Selvakumar H S - LAAS/CNRS
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma require "openrobots2-idl >= 2.1"
#pragma require "felix-idl"
#pragma require "vision-idl"

#include "or/pose/pose_estimator.gen"
#include "or/pose/rigid_body.gen"
#include "or/sensor/camera.gen"

#include "ColorTrack.idl"
#include "Environment.idl"


/* -------------------------- MODULE DECLARATION --------------------------- */
component ColorTracker {
  version "1.0";
  email	  "shasthamsa@laas.fr";
  lang	  "c";
  doc 	  "A GenoM module for the ColorTracker using a monocular camera.";

  codels-require "opencv4, felix-g3utils, eigen3, vision-idl";
  uses		or_pose_estimator;

  exception e_BAD_IMAGE_PORT { short code; string<128> message; };
  exception e_BAD_POSE_PORT { short code; string<128> message; };
  exception e_BAD_OG_PORT { short code; string<128> message; };
  exception e_BAD_TARGET_PORT { short code; string<128> message; };
  exception e_OPENCV_ERROR { short code; string<128> message; };
  exception e_OUT_OF_MEM { short code; string<128> message; };


  struct BlobMap {
    boolean is_blobbed;
    or::Environment::OccupancyGrid grid_map;
    short index;
  };

  /* -------------------------- IDS --------------------------- */
  ids {
    or::sensor::intrinsics intrinsics;	        // Camera intrinsics
    or::sensor::extrinsics extrinsics;	        // Camera extrinsics
    or::sensor::frame image_frame;		        // Image frame
    or::ColorTrack::PlateSequence plates;       // The plates sequence
    or::ColorTrack::ColorInfo color;	        // The color of the object to track

    BlobMap blob_map;
    boolean new_findings;	// true when a new findings has been found and can be published.

    unsigned short current_index;	// current free index in the plate sequence

    or_pose_estimator::state frame_pose;

    boolean debug;
    octet v_level;
  };

  /* ------------- DEFINITION OF PORTS -------------- */
  // Robot
  port in or_pose_estimator::state DronePose {
    doc "The pose of the drone.";
  };

  // Camera
  port in or::sensor::frame Frame {
    doc "The image frame to process.";
  };
  port in or::sensor::intrinsics Intrinsics;
  port in or::sensor::extrinsics Extrinsics;

  // Navigation
  port out or::Environment::OccupancyGrid OccupancyGrid {
    doc "To visualise the findings in desired tool.";};

  // ColorTracker
  port out or::ColorTrack::PlateSequence PlatesInfo {
    doc "Information on detected blobs over time.";
  }; // The plates sequence

  port out or_rigid_body::state TargetPose;


  /* ------------------ TASK DEFINITION -------------------- */
  task track {
    period 100 ms;
    doc "Track the object in the image.";

    throw e_OUT_OF_MEM, e_BAD_IMAGE_PORT;
  };

  /* ------------------ ACTIVITY DEFINITION --------------------- */

  activity color_track() {
    doc "Detect the color and keep track of coordinates from the image.";
    after set_color;
    task track;

    codel <start> FetchPorts(port in Frame, port in Intrinsics, port in Extrinsics, port in DronePose, ids in debug)
          yield pause::start, ready;
    codel <ready> InitIDS(port in Frame, port in Intrinsics, port in Extrinsics, port in DronePose,
          ids out image_frame, ids out intrinsics, ids out extrinsics, ids out frame_pose, ids out plates, ids out blob_map, ids in debug)
          yield pause::ready, main, ether;
    codel <main> TrackObject(ids in image_frame, ids in intrinsics, ids in extrinsics, ids in color, ids in frame_pose, ids inout plates, ids out blob_map, ids out new_findings,
          port out OccupancyGrid, port out PlatesInfo, ids in debug)
          yield pause::main, publish, ether;
    codel <publish> PublishOG(ids in blob_map, port out OccupancyGrid)
          yield main, ether;

    throw e_BAD_IMAGE_PORT, e_BAD_POSE_PORT, e_BAD_OG_PORT, e_BAD_TARGET_PORT, e_OPENCV_ERROR;
    interrupts color_track;
  };

  /* ------------------ SERVICE DEFINITION: Attributes -------------------- */


  /* ------------------ SERVICE DEFINITION: Functions -------------------- */
  function set_color(in or::ColorTrack::ColorInfo color_info =: "Color to be detected")
  {
    doc "Set the color to be detected.";
    codel SetColor(local in color_info, ids out color);
    throw e_OPENCV_ERROR;
  };

  function set_map_size(in octet map_width =: "Estimated map width", in octet map_height =: "Estimated map height")
  {
    doc "Set the size of the map.";
    codel SetMapSize(local in map_width, local in map_height, ids out blob_map);
    throw e_BAD_OG_PORT;
  };

  function set_debug(in boolean is_debug_mode = FALSE : "Set debug mode (default: false)" ) {
    doc "Set the debug mode.";
    codel SetDebug(local in is_debug_mode, ids out debug);
  };

  function set_verbose_level(in octet verbose_level = 0 : "Verbose level") {
    doc "Set the verbose level.";
    codel SetVerboseLevel(local in verbose_level, ids out v_level);
  };
};
